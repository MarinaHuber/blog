<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Short thoughts dumped on JSON parsing in Swift 5 - iOS Engineering</title>
  <meta name="author" content="">

  <link
    rel="stylesheet"
    type="text/css"
    href="https://webfonts.artsy.net/all-webfonts.css"
  />

  
  <meta name="description" content="Networking code can definitely be improved. Thanks Apple! No third parties here!
üëå So since Swift 4 we got Codable with Decodable and Encodable pro...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:image" content="http://artsy.github.io/images/artsy_oss_image.png" />
  <meta property="og:image:type" content="image/png" />

  
  <link rel="canonical" href="http://localhost:4000/blog/2022/09/07/quick-tips-to-speed-up-ci/">
  <link rel="alternate" type="application/rss+xml" title="Engineering Blog" href="/feed">

  <link href="/favicon.ico" rel="icon">
  <link href="/blog/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">

  <script src="/blog/javascripts/jquery-1.11.3.min.js"> </script>
  <script src="/blog/javascripts/gradient-fade.js"></script>
  <script src="/blog/javascripts/noframework.waypoints.min.js"></script>
  <script src="/blog/javascripts/sticky.min.js"></script>
  <script src="/blog/javascripts/custom-elements.min.js"></script>
  <script src="/blog/javascripts/g-emoji-element.js"></script>
  <script src="/blog/javascripts/related-articles.js"></script>

  

  <link href="/feed.xml" rel="alternate" title="iOS Engineering" type="application/atom+xml">
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-12450662-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>


<link href="/css/epic.css" media="screen, projection" rel="stylesheet" type="text/css">



<body>
  <div>
    <div id="bodywrapper">
      <header>
        <ul>
          <li><a href="/">Artsy Engineering Blog</a></li>
          <li><a href="https://www.artsy.net/jobs">Careers</a></li>
          <li><a href="https://github.com/artsy">Github</a></li>
        </ul>

        <ul>
          <li><a href="https://github.com/orgs/artsy/repositories?language=&q=&sort=&type=source">Our Open Source</a></li>
          <li><a href="http://twitter.com/artsyopensource">@artsyopensource</a></li>
          <li><a href="https://www.artsy.net">artsy.net</a></li>
        </ul>
      </header>

      <section>
        <header id="page">
          <h1>Short thoughts dumped on JSON parsing in Swift 5</h1>
          <h3>
          <!-- Yep, single line so the comma lines up right -->
          By 
          </h3>
          <time datetime="2022-09-07">Sep 7, 2022</time>
        </header>

        <article class='post'>
          <p>Networking code can definitely be improved. Thanks Apple! No third parties here!
üëå So since Swift 4 we got Codable with Decodable and Encodable protocols that 
provide support for native class (reference type), struct and enum as well (value types) all concrete data types‚Ä¶</p>

<p>First of all Codable is defined as typealias Codable = Decodable &amp; Encodable and we go for two required protocols:</p>
<ul>
  <li>Decodable: to parse JSON (get response)</li>
  <li>By decoding the JSONData we will receive/read the data
    <ol>
      <li>Encodable: to generate JSON (post response)</li>
    </ol>
  </li>
  <li>To convert your codable type into Data.</li>
</ul>

<!-- more -->

<h2 id="in-practice">In practice</h2>
<p>It works with primitive types (Int, String and Float etc.), some Foundation types (Data, URL, Date etc.) as well as with arrays, dictionaries and optionals(Enums).</p>
<ul>
  <li>NSData</li>
  <li>NSString</li>
  <li>NSNumber
    <ul>
      <li>UInt</li>
      <li>Int</li>
      <li>Float</li>
      <li>Double</li>
      <li>Bool</li>
    </ul>
  </li>
  <li>NSDate</li>
  <li>NSArray</li>
  <li>NSDictionary
Why?</li>
  <li>To simplify dependencies in our Data Manager</li>
  <li>Converting data structures to JSON data has never been easier(hmmmm..), allowing developers to store JSON data to disk or encode it into a URLRequest‚Äôs httpBody.
You can write an app that uses JSON from an external source or tests from a stub. The start problem here the inconsistencies between the structure of the concepts you‚Äôre modeling in your app and concepts modeled by the producer of the JSON. Some examples of changing and using JSON structure in your app:</li>
  <li>Change name properties with CodingKey
    <ol>
      <li>Simplify the complex structure with Encoding and Decoding manually üìù</li>
      <li>Work with Nested Data (array inside of an array JSON)
For 1. even tho we do not have to parse every element of JSON representation, we need to create properties with same name as in JSON Data or rename them with CodingKey for direct persistent storage for basic examples. Easy peasy so far! ü§†ü§†
Essential tasks here at the object level:</li>
      <li>Identify Objects</li>
      <li>Use nested type for supporting or to hide complexity
üÉè‚ô¶Ô∏èüÉè
struct SurfBoard: Codable {
 var brand: String
 var size: Size</li>
    </ol>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum CodingKeys: String, CodingKey {
    case brand = "name"
    case size
} }
</code></pre></div></div>

<p>struct Size: Codable {
    var width: Double
    var height: Double
}
Note: For JSON properties that declares in NULL element we need to mirror that instance with ‚ùìOptional. This way, data isn‚Äôt silently lost as a result of typos or a misunderstanding of the guarantees made by the provider of the JSON.
For 2. in that case, you can provide your own custom logic üìù of Encodable and Decodable to define your own encoding and decoding logic. You need to implement encode(to:) and init(from:) methods of Encodable and Decodable protocols explicitly.
On that note:
The tool that I find very useful in creating model structs faster is QuickType which is a desktop application that turns JSON into Codable with typealias for collections. I use it with copyright in comments and Equatable and Hashable protocols for making sure that collection is not duplicated‚Ä¶
Here is when the JSON goes wild and we need to taim it:
struct SurfBoard {
    var brand: String
    var size: Size</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum CodingKeys: String, CodingKey {
    case brand = "name"
    case width
    case height
} }
</code></pre></div></div>

<p>extension SurfBoard: Encodable {
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(brand, forKey: .title)
        try container.encode(size.width, forKey: .width)
        try container.encode(size.height, forKey: .height)
    }
}</p>

<p>extension SurfBoard: Decodable {
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        brand = try values.decode(String.self, forKey: .brand)
        let width = try values.decode(Double.self, forKey: .width)
        let height = try values.decode(Double.self, forKey: .height)
        size = Size(width: width, height: height)
    }
}
You can get nice use scenario here and here ‚úÖ.
For 3. in that case of Nested Data you need to decode and read the JSON. The decodable type serves as an intermediate type that‚Äôs safe to decode. It serves as the data source in an initializer for the type that you‚Äôll use in the rest of your app.
//Swift structural incompatibility with external JSON
struct SurfBoard {
    var brand: String
    var products: [Products]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Products: Codable {
    var name: String
    var points: Int
    var description: String?
} } The JSON returned by the API contains more information than is needed to populate the corresponding Swift type. //Swift structure that we need for the nested Arrays struct SurfBoard: Decodable {
let brand: String
let aisles: [Aisle]
struct Aisle: Decodable {
    let name: String
    let shelves: [Shelf]
    struct Shelf: Decodable {
       let name: String
       let product: SurfStore.Product
    }
} } The extension adds an initializer that takes a SurfBoardService instance and removes the unnecessary nesting by looping through and discarding the aisles and shelves. To extract the data you need from the outer array, you write a type that mirrors the shape of the source JSON and mark it as Decodable. Then, write an initializer on the type you‚Äôll use in the rest of your app that takes an instance of the type that mirrors the source JSON. extension SurfStore {
init(from service: SurfBoardService) {
     brand = service.brand
     products = []
     for aisle in service.aisles {
       for shelf in aisle.shelves {
         products.append(shelf.product)
        }
     }
 }  } On that note: Extensions can only provide convenience initializers * 		Initializers that are implemented as a result of protocol conformance must be marked as required(on classes). * 		required init can only be implemented within the body of a class. * 		Structs can have initializers in extensions because there is no inheritance. AND FINALLY READ THE NESTED JSON‚Ä¶ let decoder = JSONDecoder() let serviceStores = try decoder.decode([SurfBoardService].self,        from: json)
 let stores = serviceStores.compactMap { SurfBoard(from: $0) } for store in stores {
 print("\(store.name) is selling:")
for product in store.products { 
   print("\t\(product.name) (\(product.points) points)")
      if let description = product.description {
      print("\t\t\(description)")
 }    } } more in documentation: Merge Data from Different Depths Feel free to leave comments if you have any doubts üôÇ Thank you! Reference on: https://hackernoon.com/everything-about-codable-in-swift-4-97d0e18a2999 http://aplus.rs/2017/highly-maintainable-app-architecture/
</code></pre></div></div>

        </article>

        <article class='post'>
          <p style="padding-bottom: 0; margin-bottom:0;">
            <a href="https://www.artsy.net/" style="background-image: none;">
              <svg viewBox="0 0 510 510" width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                <path transform="scale(1, -1) translate(0, -480)" d="M0 -32h512v512h-512v-512v0zM464 16h-80v80h-48v-80h-288v416h416v-416v0zM194 384h-40l-74 -186h38l20 52h72l19 -52h39l-74 186v0zM149 282l25 66l24 -66h-49v0z"></path>
              </svg>
            </a>
          <p/>
        </article>

        <aside class="related-articles"></aside>

      

      </section>

      <footer>
        <article>

          <section>
            <h4>Author</h4>
            <p></p>
            <p></p>
          </section>

          <section>
            <h4>Post Meta</h4>
            <p>Sep 7, 2022</p>
            <p>Tagged: NetworkingGenericsSwift</p>
          </section>
          <br/>
          <section>
            <h4>Artsy OSS</h4>
            <ul>
              <li><a href='https://www.artsy.net'>Artsy.net</a></li>
              <li><a href='https://github.com/artsy'>Github</a></li>
              <li><a href='https://github.com/orgs/artsy/repositories?language=&q=&sort=&type=source'>Open Source</a></li>
              <li><a href='https://www.artsy.net/jobs'>Careers</a></li>
            </ul>
          </section>

          <section>
            <h4>Blog</h4>
            <ul>
              <li><a href='http://artsy.github.io/blog/archives/'>Archives</a></li>
              <!-- TODO: bring back a different version of site search  -->
              <!-- <li><a href='http://artsy.github.io/search/'>Search</a></li> -->
              <li><a href='https://github.com/artsy/artsy.github.io'>Code on GitHub</a></li>
              <li><a href='https://github.com/artsy/artsy.github.io/edit/source/_posts/2022-09-07-quick-tips-to-speed-up-ci.markdown'>Fix typos in this post</a></li>
            </ul>
          </section>

        </article>

        <article>
          <section>
            <h4>Post Series on the Blog</h4>
            <ul>
              
              <li><a href='/series/react-native-at-artsy/'>React Native at Artsy</a></li>
              
              <li><a href='/series/javascriptures/'>JavaScriptures</a></li>
              
              <li><a href='/series/stages-of-professional-growth/'>Stages of Professional Growth</a></li>
              
              <li><a href='/series/artsy-tech-stack/'>Artsy Tech Stack</a></li>
              
              <li><a href='/series/open-source-by-default/'>Open Source by Default</a></li>
              
            </ul>
          </section>

          <section>
          
          </section>
        </article>

      </footer>
    </div>
  </div>
</body>
